import java.util.Scanner;

public class Controller {
    private final Model model;
    private final View view;

    public Controller() {
        model = new Model();
        view = new View();
    }

    public Controller(Model model, View view) {
        this.model = model;
        this.view = view;
    }

    public void run() {
        InputValidator inputValidator = new InputValidator();
        TestValidator testValidator = new TestValidator();
        TestDataGenerator dataGenerator = new TestDataGenerator();
        Solver solver = new Solver();
        String enteredOption = new String();
        Scanner sc = new Scanner(System.in);
        view.printMessage(view.MENU_MSG);
        enteredOption = sc.nextLine().trim();
        while (!enteredOption.equals("4")) {
            switch (enteredOption) {
                case "1":
                    solver.setSolver(new SequentialKnapsackSolver());
                    processSingleOptions(sc, dataGenerator, solver);
                    break;
                case "2":
                    solver.setSolver(new ParallelKnapsackSolver());
                    processSingleOptions(sc, dataGenerator, solver);
                    break;
                case "3":
                    // TBD 
                    break;
            }
            view.printMessage(view.MENU_MSG);
            enteredOption = sc.nextLine().trim();
        }
    }

    public int[] IntegerToInt(Integer[] array) {
        int[] res = new int[array.length];
        for (int i = 0; i < array.length; i++) {
            res[0] = array[0];
        }
        return res;
    }

    public InputValues readItemsNumber(Scanner sc, int itemsNum) {
        view.printMessage(view.MAX_CAPACITY_ENTER_MSG);
        int maxCapacity = sc.nextInt();
        int[] values = new int[itemsNum];
        int[] weights = new int[itemsNum];
        view.printMessage(view.WORTH_ENTER_MSG);
        for (int i = 0; i < itemsNum; i++) {
            values[i] = sc.nextInt();
        }
        view.printMessage(view.WEIGHTS_ENTER_MSG);
        for (int i = 0; i < itemsNum; i++) {
            weights[i] = sc.nextInt();
        }
        return new InputValues(itemsNum, maxCapacity, values, weights);
    }

    public void processSingleOptions(Scanner sc, TestDataGenerator dataGenerator, Solver solver) {
        view.printMessage(view.SUBMENU_MSG);
        String submenuOption = sc.nextLine().trim();
        int n, maxCapacity;
        int[] values, weights;
        InputValues res;
        switch (submenuOption) {
            case "1":
                view.printMessage(view.VALUES_MANUAL_ENTER_MSG);
                n = sc.nextInt();
                res = readItemsNumber(sc, n);
                break;
            case "2":
                view.printMessage(view.VALUES_AUTOGENERATED_ENTER_MSG);
                n = sc.nextInt();
                res = dataGenerator.generateInputValues(n);
                break;
            default:
                // Replace with some other default behaviour
                view.printMessage(view.VALUES_AUTOGENERATED_ENTER_MSG);
                n = sc.nextInt();
                res = dataGenerator.generateInputValues(n);
                break;
        }
        maxCapacity = res.getMaxCapacity();
        values = res.getValues();
        weights = res.getWeights();
        view.printSolution(solver.solve(n, values, weights, maxCapacity));
    }
}
